<h1>Everything new is old again</h1>
<p><a href="https://webassembly.org/">WebAssembly</a>, the magical new peace treaty among all web browsers and operating systems to end their differences and embrace a future of peace, love, and understanding. Is this what I've been looking for? The universal language of music to produce harmony from every distinct language and dialect, no matter how botched or archaic? The melting pot whose herbs and spices can incorporate any wretched cud and transform it into golden honey? The language of languages, the language of thought? The realized concept of the computer from the being of every existing computer? How easy life is again, this will surely save us from all labor and disputes. The era of peace has begun!</p>
<p>What journey I have before me to embark on and so little I know about this. Let me lay out what I have gathered so far from this dark and wild jungle called: <i>the web</i>, the web of eternity. Let me for a moment speak in plain English.</p>
<p>WebAssembly is a specification for a platform-agnostic intermediate language and byte code. Although it is, at this moment, implemented and executable by many major web browsers, the specification does not explicitly confine it to be executed by web browser. The host environment for a WebAssembly program can be any computer program or even an operating system.</p>
<p>The WebAssembly language consists of basic instructions like those one would find in any assembly language, such as: arithmetic instructions, bitwise instructions, stack-based memory instructions, and branching and function call instructions. To my understanding, WebAssembly is incapable of accessing any services that an operating system would provide directly to a real computer program: there is nothing like a low-level system call interface that would allow WebAssembly to perform I/O or query specific system information. At bottom, WebAssembly code is only capable of manipulating integers and floating-points, allocating memory, and importing and exporting functions between itself and the host environment.</p>
<p>Now web browsers are becoming like operating systems, they are providing these so called Web APIs accessible from Javascript code to do things like draw 3D graphics, poll mouse and keyboard events, and play back audio. A WebAssembly Web API allows Javascript code to load and execute WebAssembly programs. Javascript can call functions exported from a WebAssembly program and a WebAssembly program can call functions imported to it from Javascript. So it is the job of Javascript to access a web browser's Web APIs on behalf of WebAssembly. For now, Javascript is the "glue" between WebAssembly programs and the web browser.</p>
<p>Now it is desirable to minimize the amount of Javascript running while maximizing the amount of WebAssembly that's running because WebAssembly is fast and Javascript is slow and any language can be compiled to WebAssembly.</p>
<p>A video game that is to be run inside of a web browser will thus have the following code components:</p>
<ul style="list-style-type: circle;">
	<li>WebAssembly code, pre-compiled into a platform-independent byte code for most of the computation, including the heavy ones.</li>
	<li>Javascript code that makes calls to the web browser's client-side Web APIs on behalf of WebAssembly.</li>
	<li>HTML code, which at minimum will have an HTML5 canvas element for graphics manipulation by WebAssembly indirectly through Javascript.</li>
</ul>
<p>The client only needs to have a modern web browser to run this. No need to install anything.</p>
<p>Now there apparantly exists a framework to generate all the WebAssembly, Javascript, and HTML for you from C or C++ code. A C or C++ project that makes calls to SDL and/or OpenGL can be translated into WebAssembly and Javascript by a tool called <a href="https://emscripten.org/"><i>emscriptem</i></a>. It does so by translating basic C or C++ code into WebAssembly code while translating SDL and OpenGL calls to WebGL calls. This all sounds promising because Quake III has actually been completely ported to the browser using this tool, check out: <a href="http://www.quakejs.com/">QuakeJS</a></p> 
<p>Before I begin using emscriptem, I would like to learn and write WebAssembly directly as well as the Javascript glue code directly. The Javascript glue code for WebAssembly should be written in a certain style known as <a href="http://asmjs.org/">asm.js</a>: it is a set of guidelines for writing fast and memory efficient Javascript. These guidelines mostly consist of restrictions so it is said that asm.js is a subset of Javascript. emscriptem is also capable of compiling C or C++ into asm.js Javascript.</p>
<p>Wikipedia gives a good example of C code and it's equivalent asm.js code:</p>
<figure>
<figcaption>C code</figcaption>
<pre><code>int&nbsp;f(int&nbsp;i)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i&nbsp;+&nbsp;1;<br>}<br></code></pre>
</figure>
<figure>
<figcaption>Equivalent asm.js code</figcaption>
<pre><code>function&nbsp;(i)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;|&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(i+1)&nbsp;|&nbsp;0;<br>}<br></code></pre>
</figure>
<p>The Number type in Javascript is capable of storing a double-precision floating-point or an integer of up to 64-bits. The bitwise or operator coerces the type in a variable into a number containing an integer. So it must be used on every computation that deals with integers. Likewise, the unary plus operator coerces a value into a double-precision float number. These are the only two data types that asm.js code is permitted to work with.</p>
<p>asm.js only allows arithmetic between integers and floats, function calls, and access to a "heap" which is a Javascript array of 8-bit integers. asm.js does not allow the creation of objects or strings. Validated asm.js generates practically no garbage for the garbage collector and is supposed to be way faster than non-asm.js Javascript. I don't think most people are crazy enough to write asm.js directly, instead opting to use it as a target output from a compiler.</p>
<p>From here I can begin learning WebAssembly, asm.js, and the various Web APIs offered by Firefox and Chrome to create a complete browser-contained game or I can use just WebAssembly and embed it into a host program that I create myself, completely bypassing any need for Javascript but I would most likely need to write my own WebAssembly interpreter myself; as for WebAssembly assemblers, they already exist, C++ to WebAssembly compilers also already exist, I think.</p>
