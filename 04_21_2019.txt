<h1>Notes on WebAssembly structure</h1>
<p>The task seems big, but I would like to completely bypass Javascript and make my own WebAssembly native API that can be embedded in any host application. It will be a C or C++ library.</p>
<p><a href="http://webassembly.github.io/spec/">http://webassembly.github.io/spec/</a> is where the official specification of WebAssembly resides. It describes the 3 representations of WebAssembly: the abstract representation, the binary representation, and the text representation.</p>
<p>The abstract representation is the mathematical model of a WebAssembly program, it is how a host environment would most likely represent a WebAssembly program internally without regard to program state. The abstract representation is sufficient for validating a WebAssembly program but not for executing it. The binary representation describes how a WebAssembly program should be represented as a sequence of bytes suitable for storage in a file system. The text representation describes how a WebAssembly program should be represented as human-readable and human-writable text. The abstract representation describes the structure of a WebAssembly program which can be constructed from a WebAssembly program that's stored in either binary or text form.</p>
<p>A WebAssembly program is represented as a single WebAssembly module which can be represented in C++ as:</p>
<pre><code>struct&nbsp;Module&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Function_type&gt;&nbsp;types;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Function&gt;&nbsp;functions;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Table&gt;&nbsp;tables;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Memory&gt;&nbsp;memories;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Global&gt;&nbsp;globals;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Element&gt;&nbsp;elements;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Data&gt;&nbsp;data;<br>&nbsp;&nbsp;&nbsp;&nbsp;Start&nbsp;start;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Import&gt;&nbsp;imports;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Export&gt;&nbsp;exports;<br>};<br></code></pre>
<h3><code>Module::types</code></h3>
<p><code>types</code> is a list of every function signature used by this module. For every function defined or imported in this module, it's type must match one of the types found in this list. A <code>Function_type</code> represent's a function's type and this is determined by it's input types and it's output types:</p>
<pre><code>enum&nbsp;class&nbsp;Value_type&nbsp;{&nbsp;i32,&nbsp;i64,&nbsp;f32,&nbsp;f64&nbsp;};<br>typedef&nbsp;std::vector&lt;Value_type&gt;&nbsp;Parameters_type;<br>typedef&nbsp;std::vector&lt;Value_type&gt;&nbsp;Results_type;<br>typedef&nbsp;std::pair&lt;Parameters_type,&nbsp;Results_type&gt;&nbsp;Function_type;<br></code></pre>
<p>There are only 4 types of WebAssembly values: 32-bit integer, 64-bit integer, 32-bit floating-point, and 64-bit floating-point. The signedness of an integer is unspecified and instead, different integer instructions which each assume a specific signedness for their arguments should be chosen carefully. i32, i64, f32, and f64 are the value types that can be pushed or popped on the operand stack and passed between functions. Certain WebAssembly instructions may work with other data types that can be represented inside one of these 4 data types; for example, there is an instruction which loads an 8-bit unsigned integer value from memory and pushes the result as a 32-bit integer onto the stack.</p>
<p>Even though the results type of a function type is a sequence of value types, WebAssembly 1.0 limits the length of this sequence to 1: Functions are only allowed to have 1 return value in WebAssembly 1.0.</p>
<h3><code>Module::functions</code></h3>
<pre><code>typedef&nbsp;std::uint32_t&nbsp;Type_index;<br>typedef&nbsp;std::vector&lt;Instruction&gt;&nbsp;Expression;<br>struct&nbsp;Function&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;Type_index&nbsp;type;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Value_type&gt;&nbsp;locals;<br>&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;body;<br>};<br></code></pre>
<p><code>Module::functions</code> stores the functions and their instructions.</p>
<p>Every function in a WebAssembly module contains a type index into the <code>types</code> list, indicating the function type (it's parameter types and result types) of this function. According to the specification, this index must be a 32-bit unsigned integer as well as other index types for indexing into other components of the module. A <code>Function</code> also specifies a list of it's local variable types whose values can be accessed through the <code>local.get</code> and <code>local.set</code> instructions. Finally, the body of the function is an <code>Expression</code> which is just a sequence of <code>Instruction</code>.</p>
<p>How an instruction could be represented is a little more complex and it's not obvious how one could do it through the specification so I will describe how I decided to represent an instruction near the end of this article.</p>
<h3><code>Module::tables</code></h3>
<p>What I know so far about tables is that they store indices into <code>Module::functions</code>. The instruction <code>call_indirect</code> takes a table index, dereferences the function index from that table index and calls the the associated function. The contents of a module's table can be set statically during initialization as determined by that module's <code>elements</code> component. There are no WebAssembly instructions for reading or writing the actual values stored in a table. During runtime, only the host program can access or modify the contents of a WebAssembly module's tables.</p>
<p>Based on reading the structure section of the specification, I've decided to represent the relevant types of this component as the following:</p>
<pre><code>struct&nbsp;Limits&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::uint32_t&nbsp;min;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::unique_ptr&lt;std::uint32_t&gt;&nbsp;max;<br>};<br>enum&nbsp;class&nbsp;Element_type&nbsp;{&nbsp;function_reference&nbsp;};<br>typedef&nbsp;std::pair&lt;Limits,&nbsp;Element_type&gt;&nbsp;Table_type;<br>struct&nbsp;Table&nbsp;{&nbsp;Table_type&nbsp;type;&nbsp;};<br></code></pre>
<p>A table's type has a minimum size and an optional maximum size. I decide to use unique_ptr for representing optional values; if the value of an optional field is not present, the field will be equal to <code>nullptr</code>, otherwise the present value can be obtained by dereferencing that field. C++17 introduces <code>std::optional</code> for this purpose, but I will hold off on using C++17 features until compiler support for it matures a little more.</p>
<p>Side note: Instead of <code>std::unique_ptr</code>, I may also have a class that wraps a <code>bool</code> and a <code>std::aligned_storage</code>. A boolean value of true means that the aligned storage object is initialized with a present value and can be safely accessed, otherwise the aligned storage object is not initialized. The assignment operator would copy-assign to the present value, or, if not present, construct the value in the aligned storage object. A member function <code>reset</code> would destroy the object if a value is present, thus making the optional value empty again. Unlike the unique_ptr option, this eliminates the need for allocating dynamic storage and this is probably how most compilers would implement std::optional.</p>

<p>The only element type of a table's type is a function reference which indicates that the table's type stores indices to functions. More element types may be standardized in the future.</p>
<p>WebAssembly 1.0 restricts the length of this table list to 1: so every WebAssembly module can only have 1 table total (whether that table be imported from the host program or constructed internally if not provided). In addition, the <code>call_indirect</code> instruction always operates on the table at index 0 of <code>Module::tables</code>.</p>
<h3><code>Module::memories</code></h3>
<p>A list of memory spaces that the module is free to access or modify during runtime through the load and store instructions. WebAssembly 1.0 restricts this list to size 1 and all memory instructions always operate on the memory space at index 0 of <code>Module::memories</code>.</p>
<pre><code>typedef&nbsp;Limits&nbsp;Memory_type;<br>struct&nbsp;Memory&nbsp;{&nbsp;Memory_type&nbsp;type;&nbsp;};<br></code></pre>
<p>In the abstract representation, a memory entity is only determined by it's memory type and a memory type is a minimum and maximum memory size in units of a standard WebAssembly page size which is 65,536 bytes per page. So a memory size of 1 is approximately equal to 64 kilobytes and a memory size of 16 is approximately equal to 1 megabyte.</p>
<h3><code>Module::globals</code></h3>
<p>A list of global variables belonging to this module (not including imported global variables).</p>
<pre><code>enum&nbsp;class&nbsp;Mutability&nbsp;{&nbsp;constant,&nbsp;variable&nbsp;};<br>typedef&nbsp;std::pair&lt;Mutability,&nbsp;Value_type&gt;&nbsp;Global_type;<br>struct&nbsp;Global&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;Global_type&nbsp;type;<br>&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;initializer;<br>};<br></code></pre>
<p>A global variable can be immutable (constant) or mutable (non-constant), it must be initialized with a constant expression. The specification only permits a constant expression to be a sequence of constant instructions where a constant instruction is either an instruction that pushes a literal value or an instruction that pushes the value of an imported global variable.</p>
<h3><code>Module::elements</code></h3>
<pre><code>typedef&nbsp;std::uint32_t&nbsp;Table_index;<br>typedef&nbsp;std::uint32_t&nbsp;Function_index;<br>struct&nbsp;Element&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;Table_index&nbsp;table;<br>&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;offset;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Function_index&gt;&nbsp;initializer;<br>};<br></code></pre>
<p>A WebAssembly module can statically initialize elements of it's tables with indices to functions found in <code>Module::functions</code>. For each Element e in <code>Module::elements</code>, the Table <code>tables[e.table]</code> will contain the values from <code>e.initializer</code> inserted at position resulting from <code>e.offset</code>. <code>offset</code> must be a constant expression resulting in a value type of <code>i32</code>.</p>
<p>WebAssembly 1.0 restricts each element in elements to have it's table field value equal to 0 since no WebAssembly module is allowed to have more than 1 table.</p>
<h3><code>Module::data</code></h3>
<pre><code>typedef&nbsp;std::uint8_t&nbsp;Byte;<br>typedef&nbsp;std::uint32_t&nbsp;Memory_index;<br>struct&nbsp;Data&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;Memory_index&nbsp;data;<br>&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;offset;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Byte&gt;&nbsp;initializer;<br>};<br></code></pre>
<p>Like <code>Module::elements</code> which is used to initialize <code>Module::tables</code>, <code>Module::data</code> is used to initialize <code>Module::memories</code>. The <code>data</code> field is the index of which memory space to initialize, this value must always be 0 since only 1 memory space is currently permitted in a WebAssembly module.</p>
<h3><code>Module::start</code></h3>
<pre><code>struct&nbsp;Start&nbsp;{&nbsp;Function_index&nbsp;function;&nbsp;};<br></code></pre>
<p>This holds the index to the start function. During runtime, after a module's components have been statically initialized and an instance of the module is created, the start function is ran once to complete the initialization of the WebAssembly module instance. Afterwards, the host program may choose to invoke additional functions found in the module's exports.</p>
<p>Remember: After a module has been decoded from binary or text form and into an abstract form, this abstract form is stateless. A module must be <i>instantiated</i> before being used. An instantiation of a module is called a <i>module instance</i>. There can be several module instances, each with their own state, created from the same module. All execution happens in a module instance.</p>
<h3><code>Module::imports</code></h3>
<pre><code>struct&nbsp;Import_descriptor&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;enum&nbsp;class&nbsp;Type&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;type;<br>&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type_index&nbsp;function;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Table_type&nbsp;table;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memory_type&nbsp;memory;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Global_type&nbsp;global;<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>};<br>struct&nbsp;Import&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;module;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;Import_descriptor&nbsp;descriptor;<br>};<br></code></pre>
<p>This could be better represented as a C++17 variant. <code>Module::imports</code> is a list of <code>Import</code> objects each of which describes an entity that the host program should provide to the module. An import specifies the name of an external module and the name of one of it's exports to import into the current module. The import descriptor associated with each import indicates the type of the import which must match the type of the export being imported from the external module.</p>
<p>For example, the host application can provide a <code>print</code> function from module <code>io</code>. This function would accept an <code>i32</code> which is the index of the null-terminated string to print which resides in the module instance's first memory space. The function would have no return value.</p>
<p>If this is the first import for the module, then the C++ initializer for this import would be:</p>
<pre><code>{&nbsp;"io",&nbsp;"print",&nbsp;{&nbsp;Import_descriptor::Type::function,&nbsp;0&nbsp;}&nbsp;}<br></code></pre>
<p>and the element at index 0 of the module's <code>types</code> component would be initialized with:</p>
<pre><code>{&nbsp;{&nbsp;Value_type::i32&nbsp;},&nbsp;{}&nbsp;}<br></code></pre>
<h3><code>Module::exports</code></h3>
<pre><code>struct&nbsp;Export_descriptor&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;enum&nbsp;class&nbsp;Type&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;type;<br>&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function_index&nbsp;function;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Table_index&nbsp;table;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memory_index&nbsp;memory;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Global_index&nbsp;global;<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>};<br>struct&nbsp;Export&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;Export_descriptor&nbsp;descriptor;<br>};<br></code></pre>
<p>Each export from <code>Module::exports</code> indicates which entity to export from this module by providing an index and the type of the export which indicates which index-space the entity to be exported exists in. Every export is given a name which can later be identified by the host program or other modules when importing.</p>
<h3>My abstract representation of a WebAssembly Instruction</h3>
<pre><code>struct&nbsp;Instruction&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;enum&nbsp;class&nbsp;Type&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unreachable,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nop,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block_end,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop_end,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if_else_end,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;br,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;br_if,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;br_table,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret,&nbsp;/*&nbsp;return&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call_indirect,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drop,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local_get,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local_set,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local_tee,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global_get,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global_set,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_load,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_load,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_load,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_load,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_load_8_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_load_8_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_load_16_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_load_16_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_load_8_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_load_8_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_load_16_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_load_16_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_load_32_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_load_32_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_store,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_store,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_store,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_store,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_store_8,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_store_16,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_store_8,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_store_16,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_store_32,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_size,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_grow,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_const,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_const,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_const,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_const,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_eqz,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_eq,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_ne,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_lt_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_lt_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_gt_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_gt_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_le_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_le_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_ge_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_ge_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_eqz,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_eq,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_ne,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_lt_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_lt_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_gt_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_gt_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_le_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_le_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_ge_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_ge_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_eq,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_ne,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_lt,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_gt,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_le,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_ge,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_eq,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_ne,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_lt,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_gt,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_le,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_ge,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_clz,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_ctz,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_popcnt,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_add,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_sub,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_mul,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_div_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_div_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_rem_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_rem_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_and,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_or,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_xor,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_shl,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_shr_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_shr_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_rotl,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_rotr,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_clz,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_ctz,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_popcnt,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_add,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_sub,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_mul,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_div_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_div_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_rem_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_rem_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_and,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_or,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_xor,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_shl,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_shr_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_shr_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_rotl,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_rotr,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_abs,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_neg,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_ceil,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_floor,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_trunc,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_nearest,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_sqrt,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_add,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_sub,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_mul,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_div,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_min,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_max,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_copysign,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_abs,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_neg,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_ceil,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_floor,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_trunc,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_nearest,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_sqrt,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_add,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_sub,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_mul,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_div,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_min,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_max,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_copysign,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_wrap_i64,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_trunc_f32_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_trunc_f32_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_trunc_f64_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_trunc_f64_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_extend_i32_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_extend_i32_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_trunc_f32_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_trunc_f32_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_trunc_f64_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_trunc_f64_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_convert_i32_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_convert_i32_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_convert_i64_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_convert_i64_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_demote_f64,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_convert_i32_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_convert_i32_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_convert_i64_s,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_convert_i64_u,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_promote_f32,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i32_reinterpret_f32,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i64_reinterpret_f64,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f32_reinterpret_i32,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f64_reinterpret_i64<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;Immediate&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I32&nbsp;i32;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I64&nbsp;i64;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F32&nbsp;f32;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F64&nbsp;f64;<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;type;<br>&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Immediate&nbsp;arguments&nbsp;for&nbsp;simple&nbsp;instructions&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Immediate&gt;&nbsp;arguments;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Data&nbsp;for&nbsp;structured&nbsp;instructions&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Optional&nbsp;result&nbsp;type&nbsp;of&nbsp;this&nbsp;block&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::unique_ptr&lt;Result_type&gt;&nbsp;result_type;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Nested&nbsp;instructions&nbsp;for&nbsp;this&nbsp;block&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Instruction&gt;&nbsp;nested;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Optional&nbsp;"else&nbsp;clause"&nbsp;nested&nbsp;instructions.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Only&nbsp;applies&nbsp;to&nbsp;the&nbsp;if_else_end&nbsp;instruction.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::unique_ptr&lt;&nbsp;std::vector&lt;Instruction&gt;&nbsp;&gt;&nbsp;nested_else;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;block;<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>};</code></pre>
<p>There are 2 main types of instructions in WebAssembly: simple instructions and structured instructions. A simple instruction performs one action and can have immediate arguments. A structured instruction cannot have immediate arguments. A structured instruction forms a block which can have nested instructions and thus can perform multiple actions. A structured instruction can also have an optional result type like that of a function.</p>
<p>The following structured instructions, with (...) being their nested instructions, form instruction blocks:</p>
<pre><code>block<br>...<br>end</code></pre>
<pre><code>loop<br>...<br>end</code></pre>
<pre><code>if<br>...<br>else<br>...<br>end</code></pre>
<p>The <code>else</code> clause of an <code>if</code> instruction is optional. Besides these 3 instructions, all other instructions are simple instructions.</p>
<p><code>else</code> and <code>end</code> are also known as <i>pseudo-instructions</i> because they don't exist in the abstract representation, but they do exist in the text and binary representations to delimit the parts of the structured instruction. <code>end</code> is also used as the ending pseudo-instruction for a function or expression.</p>
